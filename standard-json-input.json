{
  "language": "Solidity",
  "sources": {
    "contracts/DI.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\ncontract DI is ERC20, ERC20Permit, ERC20Votes, Ownable {\r\n    uint256 public constant TOTAL_SUPPLY = 1_000_000_000 ether;\r\n\r\n    struct AllocationAddresses {\r\n        address presaleContract;\r\n        address marketingWallet;\r\n        address teamAllocationContract;\r\n        address airdropContract;\r\n        address stakingContract;\r\n        address kolAllocationContract;\r\n        address treasuryWallet;\r\n        address ecosystemWallet;\r\n        address liquidityWallet;\r\n    }\r\n\r\n    AllocationAddresses public allocationAddresses;\r\n\r\n    constructor(address _owner)\r\n        ERC20(\"DI Network\", \"DI\")\r\n        ERC20Permit(\"DI\")\r\n        Ownable(_owner)\r\n    {\r\n           \r\n    }\r\n\r\n    function allocateToken(AllocationAddresses memory addrs) external onlyOwner {\r\n        require(\r\n            addrs.presaleContract != address(0) &&\r\n            addrs.marketingWallet != address(0) &&\r\n            addrs.kolAllocationContract != address(0) &&\r\n            addrs.teamAllocationContract != address(0) &&\r\n            addrs.treasuryWallet != address(0) &&\r\n            addrs.ecosystemWallet != address(0) &&\r\n            addrs.stakingContract != address(0) &&\r\n            addrs.liquidityWallet != address(0) &&\r\n            addrs.airdropContract != address(0),\r\n            \"Invalid address\"\r\n        );\r\n\r\n        allocationAddresses.presaleContract = addrs.presaleContract;\r\n        allocationAddresses.marketingWallet = addrs.marketingWallet;\r\n        allocationAddresses.kolAllocationContract = addrs.kolAllocationContract;\r\n        allocationAddresses.teamAllocationContract = addrs.teamAllocationContract;\r\n        allocationAddresses.treasuryWallet = addrs.treasuryWallet;\r\n        allocationAddresses.ecosystemWallet = addrs.ecosystemWallet;\r\n        allocationAddresses.stakingContract = addrs.stakingContract;\r\n        allocationAddresses.liquidityWallet = addrs.liquidityWallet;\r\n        allocationAddresses.airdropContract = addrs.airdropContract;     \r\n            \r\n        uint256 presaleAllocation = 150_000_000 ether;\r\n        uint256 marketingAllocation = 100_000_000 ether;\r\n        uint256 kolAllocation = 50_000_000 ether;\r\n        uint256 teamAllocation = 50_000_000 ether;\r\n        uint256 treasuryAllocation = 150_000_000 ether;\r\n        uint256 ecosystemAllocation = 300_000_000 ether;\r\n        uint256 stakingAllocation = 100_000_000 ether;\r\n        uint256 liquidityAllocation = 150_000_000 ether;\r\n        uint256 airdropAllocation = 50_000_000 ether;\r\n\r\n        // Mint\r\n        _mint(allocationAddresses.presaleContract, presaleAllocation);\r\n        _mint(allocationAddresses.marketingWallet, marketingAllocation);\r\n        _mint(allocationAddresses.kolAllocationContract, kolAllocation);\r\n        _mint(allocationAddresses.teamAllocationContract, teamAllocation);\r\n        _mint(allocationAddresses.treasuryWallet, treasuryAllocation);\r\n        _mint(allocationAddresses.ecosystemWallet, ecosystemAllocation - stakingAllocation);\r\n        _mint(allocationAddresses.stakingContract, stakingAllocation);\r\n        _mint(allocationAddresses.liquidityWallet, liquidityAllocation);\r\n        _mint(allocationAddresses.airdropContract, airdropAllocation);\r\n    }\r\n\r\n    function totalSupply() public pure override returns (uint256) {\r\n        return TOTAL_SUPPLY;\r\n    }\r\n\r\n    // Required overrides\r\n    function _update(address from, address to, uint256 value)\r\n        internal\r\n        override(ERC20, ERC20Votes)\r\n    {\r\n        super._update(from, to, value);\r\n    }\r\n\r\n    function nonces(address sender)\r\n        public\r\n        view\r\n        override(ERC20Permit, Nonces)\r\n        returns (uint256)\r\n    {\r\n        return super.nonces(sender);\r\n    }\r\n}"
    },
    "contracts/DIVote.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\ncontract DIVote is Ownable {\r\n    enum VoteType { YesNo, MultipleChoice }\r\n\r\n    struct Proposal {\r\n        string title;\r\n        string description;\r\n        VoteType voteType;\r\n        string[] choices;\r\n        uint256 startTime;\r\n        uint256 endTime;\r\n        uint256 quorum;\r\n        mapping(uint256 => uint256) votes;\r\n        mapping(address => bool) hasVoted;\r\n        mapping(address => uint256) voterWeights;\r\n        address[] voterList;\r\n    }\r\n\r\n    ERC20Votes public voteToken;\r\n    uint256 public proposalCount;\r\n\r\n    mapping(uint256 => Proposal) private proposals;\r\n\r\n    event ProposalCreated(uint256 indexed proposalId, string title, uint256 quorum);\r\n    event Voted(uint256 indexed proposalId, address indexed voter, uint256 weight, uint256 choice);\r\n\r\n    constructor(ERC20Votes _voteToken, address _owner) Ownable(_owner) {\r\n        voteToken = _voteToken;\r\n    }\r\n\r\n    function createProposal(\r\n        string calldata _title,\r\n        string calldata _description,\r\n        VoteType _voteType,\r\n        string[] calldata _choices,\r\n        uint256 _duration,\r\n        uint256 _quorum\r\n    ) external onlyOwner {\r\n        require(_choices.length >= 2, \"At least two choices required\");\r\n\r\n        Proposal storage p = proposals[proposalCount];\r\n        p.title = _title;\r\n        p.description = _description;\r\n        p.voteType = _voteType;\r\n        p.startTime = block.timestamp;\r\n        p.endTime = block.timestamp + _duration;\r\n        p.quorum = _quorum;\r\n\r\n        for (uint256 i = 0; i < _choices.length; i++) {\r\n            p.choices.push(_choices[i]);\r\n        }\r\n\r\n        emit ProposalCreated(proposalCount, _title, _quorum);\r\n        proposalCount++;\r\n    }\r\n\r\n    function vote(uint256 _proposalId, uint256 _choice) external {\r\n        Proposal storage p = proposals[_proposalId];\r\n        require(block.timestamp >= p.startTime && block.timestamp <= p.endTime, \"Voting not active\");\r\n        require(!p.hasVoted[msg.sender], \"Already voted\");\r\n        require(_choice < p.choices.length, \"Invalid choice\");\r\n\r\n        uint256 weight = voteToken.getPastVotes(msg.sender, p.startTime);\r\n        require(weight > 0, \"No voting power at proposal start\");\r\n\r\n        p.votes[_choice] += weight;\r\n        p.hasVoted[msg.sender] = true;\r\n        p.voterWeights[msg.sender] = weight;\r\n        p.voterList.push(msg.sender);\r\n\r\n        emit Voted(_proposalId, msg.sender, weight, _choice);\r\n    }\r\n\r\n    function getProposal(uint256 _proposalId)\r\n        external\r\n        view\r\n        returns (\r\n            string memory title,\r\n            string memory description,\r\n            VoteType voteType,\r\n            string[] memory choices,\r\n            uint256 startTime,\r\n            uint256 endTime,\r\n            uint256 quorum\r\n        )\r\n    {\r\n        Proposal storage p = proposals[_proposalId];\r\n        return (p.title, p.description, p.voteType, p.choices, p.startTime, p.endTime, p.quorum);\r\n    }\r\n\r\n    function getVotes(uint256 _proposalId) external view returns (uint256[] memory) {\r\n        Proposal storage p = proposals[_proposalId];\r\n        uint256[] memory result = new uint256[](p.choices.length);\r\n        for (uint256 i = 0; i < p.choices.length; i++) {\r\n            result[i] = p.votes[i];\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function getVoters(uint256 _proposalId) external view returns (address[] memory, uint256[] memory) {\r\n        Proposal storage p = proposals[_proposalId];\r\n        uint256 length = p.voterList.length;\r\n        address[] memory voters = new address[](length);\r\n        uint256[] memory weights = new uint256[](length);\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            address voter = p.voterList[i];\r\n            voters[i] = voter;\r\n            weights[i] = p.voterWeights[voter];\r\n        }\r\n\r\n        return (voters, weights);\r\n    }\r\n\r\n    function hasQuorum(uint256 _proposalId) public view returns (bool) {\r\n        Proposal storage p = proposals[_proposalId];\r\n        uint256 totalVotes = 0;\r\n        for (uint256 i = 0; i < p.choices.length; i++) {\r\n            totalVotes += p.votes[i];\r\n        }\r\n        return totalVotes >= p.quorum;\r\n    }\r\n\r\n    function getResult(uint256 _proposalId) external view returns (string memory result, bool quorumMet) {\r\n        Proposal storage p = proposals[_proposalId];\r\n        quorumMet = hasQuorum(_proposalId);\r\n        if (!quorumMet) {\r\n            return (\"Quorum not met\", false);\r\n        }\r\n\r\n        uint256 winningVote = 0;\r\n        uint256 maxVotes = 0;\r\n\r\n        for (uint256 i = 0; i < p.choices.length; i++) {\r\n            if (p.votes[i] > maxVotes) {\r\n                maxVotes = p.votes[i];\r\n                winningVote = i;\r\n            }\r\n        }\r\n\r\n        result = p.choices[winningVote];\r\n    }\r\n}"
    },
    "contracts/GasCreditVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {IERC20, IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {AggregatorV3Interface} from \"@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/**\n * @title GasCreditVault\n * @dev A vault contract that allows users to deposit tokens and receive credits for gas payments\n * Features:\n * - Multi-token support with stablecoin and price feed integration\n * - Credit-based system for gas payment abstraction\n * - Relayer-based consumption model\n * - Owner withdrawal of consumed credits\n * - Emergency pause functionality\n * - Upgradeable contract pattern\n */\ncontract GasCreditVault is Initializable, OwnableUpgradeable, UUPSUpgradeable  {\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    \n    /**\n     * @dev Token information structure\n     * @param priceFeed Chainlink price feed interface for non-stablecoin tokens\n     * @param isStablecoin Whether the token is a stablecoin (1:1 USD)\n     */\n    struct TokenInfo {\n        AggregatorV3Interface priceFeed;\n        bool isStablecoin;\n    }\n    \n    // Events\n    event TokenWhitelisted(address indexed token, address priceFeed);\n    event TokenRemoved(address indexed token);\n    event Deposited(address indexed user, address indexed token, uint256 amount, uint256 credited);\n    event Withdrawn(address indexed user, address indexed token, uint256 amount, uint256 credited);\n    event CreditsConsumed(address indexed user, uint256 usdValue, uint256 creditCost);\n    event CreditTransfer(address indexed sender, address indexed receiver, uint256 creditAmount);\n    event OwnerWithdrawn(address indexed token, uint256 amount, uint256 creditedConsumed);\n    event RelayerAdded(address indexed relayer);\n    event RelayerRemoved(address indexed relayer);\n    event EmergencyWithdrawn(address indexed to, uint256 amount);\n    event Paused();\n    event Unpaused();\n\n    // State variables\n    EnumerableSet.AddressSet private whitelistedTokens;\n    EnumerableSet.AddressSet private relayers;\n\n    mapping(address => TokenInfo) public tokenInfo;\n    mapping(address => uint256) public credits;\n    mapping(address => mapping(address => uint256)) public creditsInToken;\n    \n    uint256 public totalConsumedCreditsWithdrawn;\n    uint256 public totalConsumedCredits;\n\n    uint256 public minimumConsume;\n    uint8 public constant creditDecimals = 18;\n    uint256 public constant PRICE_FEED_TIMEOUT = 3600; // 1 hour for stale price protection\n\n    bool public paused;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Initializes the contract with default settings\n     * @notice This function can only be called once during deployment\n     * Sets up ownership, upgradeability, and default minimum consume amount\n     */\n    function initialize() public initializer {\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n        minimumConsume = 0.5 ether;\n    }\n\n    // Modifiers\n    \n    /**\n     * @dev Modifier to restrict function access to whitelisted relayers only\n     */\n    modifier onlyRelayer() {\n        require(relayers.contains(msg.sender), \"Caller not whitelisted relayers\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to ensure the token is a stablecoin\n     * @param token The token address to check\n     */\n    modifier onlyStablecoin(address token) {\n        require(tokenInfo[token].isStablecoin, \"Token not stablecoin\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to prevent function execution when contract is paused\n     */\n    modifier whenNotPaused() {\n        require(!paused, \"Paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to ensure function execution only when contract is paused\n     */\n    modifier whenPaused() {\n        require(paused, \"Unpaused\");\n        _;\n    }\n    // Owner functions ==============================================\n\n    /**\n     * @dev Adds a new relayer to the whitelist\n     * @param relayer The address of the relayer to add\n     * @notice Only owner can call this function\n     * @notice Relayer address must not be zero and not already whitelisted\n     */\n    function addWhitelistedRelayer(address relayer) external onlyOwner {\n        require(relayer != address(0), \"Invalid address\");\n        require(!relayers.contains(relayer), \"Relayer already whitelisted\");\n\n        relayers.add(relayer);\n\n        emit RelayerAdded(relayer);\n    }\n\n    /**\n     * @dev Removes a relayer from the whitelist\n     * @param relayer The address of the relayer to remove\n     * @notice Only owner can call this function\n     * @notice Relayer must be currently whitelisted\n     */\n    function removeWhitelistedRelayer(address relayer) external onlyOwner {\n        require(relayers.contains(relayer), \"Relayer not whitelisted\");\n\n        relayers.remove(relayer);\n\n        emit RelayerRemoved(relayer);\n    }\n\n    /**\n     * @dev Adds a token to the whitelist with price feed configuration\n     * @param token The token contract address\n     * @param priceFeed The Chainlink price feed address (can be zero for stablecoins)\n     * @param isStablecoin Whether the token is a stablecoin (1:1 USD value)\n     * @notice Only owner can call this function\n     * @notice Token must not already be whitelisted\n     * @notice Non-stablecoins must have a valid price feed\n     */\n    function whitelistToken(\n        address token,\n        address priceFeed,\n        bool isStablecoin\n    ) external onlyOwner {\n        require(token != address(0), \"Invalid token address\");\n        require(!whitelistedTokens.contains(token), \"Token already whitelisted\");\n        require(isStablecoin || priceFeed != address(0), \"Invalid price feed\");\n        \n        whitelistedTokens.add(token);\n        tokenInfo[token] = TokenInfo({\n            priceFeed: AggregatorV3Interface(priceFeed),\n            isStablecoin: isStablecoin\n        });\n\n        emit TokenWhitelisted(token, priceFeed);\n    }\n\n    /**\n     * @dev Removes a token from the whitelist\n     * @param token The token contract address to remove\n     * @notice Only owner can call this function\n     * @notice Token must have zero balance in the contract\n     * @notice Token must be currently whitelisted\n     */\n    function removeToken(address token) external onlyOwner {\n        require(IERC20(token).balanceOf(address(this)) == 0, \"None Zero Balance\");\n        require(whitelistedTokens.contains(token), \"Token not whitelisted\");\n        whitelistedTokens.remove(token);\n        delete tokenInfo[token];\n\n        emit TokenRemoved(token);\n    }\n\n    /**\n     * @dev Pauses the contract, preventing deposits, withdrawals, and transfers\n     * @notice Only owner can call this function\n     * @notice Contract must not already be paused\n     */\n    function pause() external onlyOwner {\n        require(!paused, \"Already paused\");\n        paused = true;\n        emit Paused();\n    }\n\n    /**\n     * @dev Unpauses the contract, allowing normal operations\n     * @notice Only owner can call this function\n     * @notice Contract must be currently paused\n     */\n    function unpause() external onlyOwner {\n        require(paused, \"Not paused\");\n        paused = false;\n        emit Unpaused();\n    }\n\n    /**\n     * @dev Emergency function to withdraw all tokens to owner\n     * @notice Only owner can call this function\n     * @notice Should only be used in emergency situations\n     * @notice Withdraws all balances of whitelisted tokens\n     */\n    function emergencyWithdraw() external onlyOwner {\n        address[] memory tokens = whitelistedTokens.values();\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            address token = tokens[i];\n            uint256 balance = IERC20(token).balanceOf(address(this));\n            if (balance > 0) {\n                IERC20(token).safeTransfer(owner(), balance);\n                emit EmergencyWithdrawn(token, balance);\n            }\n        }        \n    }\n\n    /**\n     * @dev Sets the minimum consumption amount\n     * @param _minimum The new minimum consumption amount in credit decimals\n     * @notice Only owner can call this function\n     * @notice Minimum must be greater than zero\n     */\n    function setMinimumConsume(uint256 _minimum) external onlyOwner {\n        require(_minimum > 0, \"Minimum must be > 0\");\n        minimumConsume = _minimum;\n    }\n\n    // User functions ==============================================\n    \n    /**\n     * @dev Allows users to deposit tokens and receive credits\n     * @param token The token contract address to deposit\n     * @param amount The amount of tokens to deposit\n     * @notice Token must be whitelisted and amount must be greater than zero\n     * @notice Contract must not be paused\n     * @notice Credits are calculated based on token price and decimals\n     */\n    function deposit(address token, uint256 amount) external whenNotPaused {\n        require(whitelistedTokens.contains(token), \"Token not whitelisted\");\n        require(amount > 0, \"Amount must be > 0\");\n\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n\n        uint256 creditedAmount = calculateCreditValue(token, amount);\n\n        credits[msg.sender] += creditedAmount;\n        creditsInToken[msg.sender][token] += creditedAmount;\n\n        emit Deposited(msg.sender, token, amount, creditedAmount);\n    }\n\n    /**\n     * @dev Allows users to withdraw stablecoins using their credits\n     * @param token The stablecoin contract address to withdraw\n     * @param creditAmount The amount of credits to convert to tokens\n     * @notice Only works with stablecoins\n     * @notice User must have sufficient credits in the specified token\n     * @notice Contract must not be paused\n     * @notice Vault must have sufficient token balance\n     */\n    function withdraw(address token, uint256 creditAmount) external whenNotPaused onlyStablecoin(token) {\n        require(creditsInToken[msg.sender][token] >= creditAmount, \"Insufficient token balance\");\n\n        uint256 tokenAmount = calculateTokenValue(token, creditAmount);\n        require(IERC20(token).balanceOf(address(this)) >= tokenAmount, \"Insufficient token in Vault\");\n\n        // Update credits\n        credits[msg.sender] -= creditAmount;\n        creditsInToken[msg.sender][token] -= creditAmount;\n\n        IERC20(token).safeTransfer(msg.sender, tokenAmount);\n\n        emit Withdrawn(msg.sender, token, tokenAmount, creditAmount);\n    }\n\n    // Consumption function ====================================\n    \n    /**\n     * @dev Allows relayers to consume user credits for gas payment\n     * @param user The user whose credits will be consumed\n     * @param usdValue The USD value of gas consumed\n     * @notice Only whitelisted relayers can call this function\n     * @notice Uses minimum consume amount if usdValue is below threshold\n     * @notice Deducts credits proportionally from user's token positions\n     */\n    function consumeCredit(address user, uint256 usdValue) external onlyRelayer {\n        require(user != address(0), \"Invalid user address\");\n        require(usdValue > 0, \"Value must be > 0\");\n\n        uint256 creditCost = usdValue > minimumConsume ? usdValue : minimumConsume;\n\n        require(credits[user] >= creditCost, \"Insufficient credits\");\n\n        uint256 remaining = creditCost;\n\n        // Iterate over whitelisted tokens and deduct credited and deposited accordingly\n        address[] memory tokens = whitelistedTokens.values();\n        for (uint256 i = 0; i < tokens.length && remaining > 0; ++i) {\n            address token = tokens[i];\n            uint256 userCredited = creditsInToken[user][token];\n\n            if (userCredited == 0) continue;\n\n            uint256 deduction = userCredited >= remaining ? remaining : userCredited;\n\n            creditsInToken[user][token] -= deduction;\n\n            remaining -= deduction;\n        }\n\n        credits[user] -= creditCost;\n        totalConsumedCredits += creditCost;\n        \n        emit CreditsConsumed(user, usdValue, creditCost);\n    }\n\n    /**\n     * @dev Allows users to transfer credits to another address\n     * @param receiver The address to receive the credits\n     * @param credit The amount of credits to transfer\n     * @notice Contract must not be paused\n     * @notice Credit amount must be above minimum and sender must have sufficient balance\n     * @notice Credits are transferred proportionally from sender's token positions to receiver\n     */\n    function transferCredit(address receiver, uint256 credit) external whenNotPaused {\n        address sender = msg.sender;\n        require(receiver != address(0), \"Invalid receiver address\");\n        require(credit > minimumConsume && credits[sender] >= credit, 'Invalid amount');\n        \n        uint256 remaining = credit;\n        address[] memory tokens = whitelistedTokens.values();\n        for (uint256 i = 0; i < tokens.length && remaining > 0; ++i) {\n            address token = tokens[i];\n            uint256 userCredited = creditsInToken[sender][token];\n\n            if (userCredited == 0) continue;\n\n            uint256 deduction = userCredited >= remaining ? remaining : userCredited;\n\n            creditsInToken[sender][token] -= deduction;\n            creditsInToken[receiver][token] += deduction;\n            remaining -= deduction;\n        }\n\n        credits[receiver] += credit;\n        credits[sender] -= credit;\n        emit CreditTransfer(sender, receiver, credit);\n    }\n\n        /**\n     * @dev Allows owner to withdraw tokens corresponding to consumed credits\n     * @notice Only owner can call this function\n     * @notice Only withdraws new consumed credits since last withdrawal\n     * @notice Proportionally withdraws from all token balances based on consumed credits\n     */\n    function withdrawConsumedCredits() external onlyOwner {\n        require(totalConsumedCredits > totalConsumedCreditsWithdrawn, \"No new credits to withdraw\");\n\n        uint256 deltaCredits = totalConsumedCredits - totalConsumedCreditsWithdrawn;\n        totalConsumedCreditsWithdrawn = totalConsumedCredits; // Fix: Update the withdrawn amount\n\n        address[] memory tokens = whitelistedTokens.values();\n\n        // Calculate and withdraw tokens corresponding to consumed credits\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            address token = tokens[i];\n\n            // Get the token balance for the contract\n            uint256 contractBalance = IERC20(token).balanceOf(address(this));\n            if (contractBalance == 0) continue;\n\n            // Calculate the credit value for the token balance in terms of consumed credits\n            uint256 tokenValueInCredits = calculateCreditValue(token, contractBalance);\n\n            // Withdraw the corresponding amount of tokens based on the consumed credits\n            uint256 tokenAmount = (deltaCredits * contractBalance) / tokenValueInCredits;\n\n            // Ensure we don't withdraw more than the available balance\n            if (tokenAmount > contractBalance) {\n                tokenAmount = contractBalance;\n            }\n\n            // If tokenAmount is greater than zero, withdraw it to the owner\n            if (tokenAmount > 0) {\n                IERC20(token).safeTransfer(owner(), tokenAmount);\n                emit OwnerWithdrawn(token, tokenAmount, deltaCredits);\n            }\n        }\n    }\n\n    // Price calculation functions ================================\n    \n    /**\n     * @dev Calculates the credit value for a given token amount\n     * @param token The token contract address\n     * @param amount The amount of tokens\n     * @return The equivalent credit value in credit decimals\n     * @notice For stablecoins, assumes 1:1 USD ratio\n     * @notice For other tokens, uses Chainlink price feed\n     */\n    function calculateCreditValue(address token, uint256 amount) internal view returns (uint256) {\n        TokenInfo memory info = tokenInfo[token];\n        uint8 tokenDecimals = IERC20Metadata(token).decimals();\n        \n        if (info.isStablecoin) {\n            return convertDecimals(amount, tokenDecimals, creditDecimals);\n        }\n\n        (uint80 roundId, int256 price, , uint256 updatedAt, uint80 answeredInRound) = info.priceFeed.latestRoundData();\n        \n        // Price feed validation\n        require(price > 0, \"Invalid price from feed\");\n        require(updatedAt > 0, \"Invalid timestamp from feed\");\n        require(block.timestamp - updatedAt <= PRICE_FEED_TIMEOUT, \"Price feed too stale\");\n        require(answeredInRound >= roundId, \"Price feed round incomplete\");\n        \n        uint8 _decimals = tokenDecimals + info.priceFeed.decimals();\n        \n        // Formula: (amount * price) / (10^(tokenDecimals + priceFeedDecimals - creditDecimals))\n        return convertDecimals(amount * uint256(price), _decimals, creditDecimals);\n    }\n\n    /**\n     * @dev Calculates the token amount for a given credit value\n     * @param token The token contract address\n     * @param creditAmount The amount of credits\n     * @return The equivalent token amount in token decimals\n     * @notice For stablecoins, assumes 1:1 USD ratio\n     * @notice For other tokens, uses Chainlink price feed\n     */\n    function calculateTokenValue(address token, uint256 creditAmount) internal view returns (uint256) {\n        TokenInfo memory info = tokenInfo[token];\n        uint8 tokenDecimals = IERC20Metadata(token).decimals();\n\n        if (info.isStablecoin) {\n            return convertDecimals(creditAmount, creditDecimals, tokenDecimals);\n        }\n\n        (uint80 roundId, int256 price, , uint256 updatedAt, uint80 answeredInRound) = info.priceFeed.latestRoundData();\n        \n        // Price feed validation\n        require(price > 0, \"Invalid price from feed\");\n        require(updatedAt > 0, \"Invalid timestamp from feed\");\n        require(block.timestamp - updatedAt <= PRICE_FEED_TIMEOUT, \"Price feed too stale\");\n        require(answeredInRound >= roundId, \"Price feed round incomplete\");\n        \n        uint8 priceFeedDecimals = info.priceFeed.decimals();\n        \n        // Fix precision: multiply first, then divide\n        // Formula: (creditAmount * 10^(tokenDecimals + priceFeedDecimals)) / (price * 10^creditDecimals)\n        uint256 numerator = convertDecimals(creditAmount, creditDecimals, creditDecimals + tokenDecimals + priceFeedDecimals);\n        return numerator / uint256(price);\n    }\n\n    /**\n     * @dev Converts amounts between different decimal precisions\n     * @param amount The amount to convert\n     * @param from The source decimal precision\n     * @param to The target decimal precision\n     * @return The converted amount\n     * @notice Uses unchecked arithmetic for gas optimization\n     */\n    function convertDecimals(uint256 amount, uint8 from, uint8 to) internal pure returns (uint256) {\n        unchecked {\n            return from > to ? \n                amount / (10 ** (from - to)) :\n                amount * (10 ** (to - from));\n        }\n    }\n\n    /**\n     * @dev Authorizes contract upgrades (UUPS pattern)\n     * @param newImplementation The address of the new implementation\n     * @notice Only owner can authorize upgrades\n     */\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n\n\n    // View functions =============================================\n    \n    /**\n     * @dev Returns the list of all whitelisted token addresses\n     * @return Array of whitelisted token addresses\n     */\n    function getWhitelistedTokens() external view returns (address[] memory) {\n        return whitelistedTokens.values();\n    }\n\n    /**\n     * @dev Returns the list of all whitelisted relayer addresses\n     * @return Array of whitelisted relayer addresses\n     */\n    function getWhitelistedRelayers() external view returns (address[] memory) {\n        return relayers.values();\n    }\n\n    /**\n     * @dev Calculates the credit value for a given token amount (external view)\n     * @param token The token contract address\n     * @param amount The amount of tokens\n     * @return The equivalent credit value\n     */\n    function getCreditValue(address token, uint256 amount) external view returns (uint256) {\n        return calculateCreditValue(token, amount);\n    }\n\n    /**\n     * @dev Calculates the token amount for a given credit value (external view)\n     * @param token The token contract address\n     * @param creditAmount The amount of credits\n     * @return The equivalent token amount\n     */\n    function getTokenValue(address token, uint256 creditAmount) external view returns (uint256) {\n        return calculateTokenValue(token, creditAmount);\n    }\n\n    /**\n     * @dev Checks if a token is whitelisted\n     * @param token The token contract address to check\n     * @return Whether the token is whitelisted\n     */\n    function isTokenWhitelisted(address token) external view returns (bool) {\n        return whitelistedTokens.contains(token);\n    }\n\n    /**\n     * @dev Checks if an address is a whitelisted relayer\n     * @param relayer The address to check\n     * @return Whether the address is a whitelisted relayer\n     */\n    function isRelayerWhitelisted(address relayer) external view returns (bool) {\n        return relayers.contains(relayer);\n    }\n}"
    },
    "contracts/KOLAllocation.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ncontract KOLAllocation is Ownable {\r\n    struct Member {\r\n        string name;\r\n        uint256 balance;\r\n        uint256 startTime;\r\n        uint256 withdrawn;\r\n    }\r\n\r\n    IERC20 public immutable token;\r\n\r\n    uint256 public constant VESTING_DURATION = 180 days;\r\n    uint256 public constant CLIFF_DURATION = 30 days;\r\n    uint256 private constant NOT_FOUND = type(uint256).max;\r\n\r\n    address[] public wallets;\r\n    Member[] public membersInfo;\r\n\r\n    uint256 public totalAllocated;\r\n    uint256 public totalWithdrawn;\r\n\r\n    constructor(address _token, address _owner) Ownable(_owner) {\r\n        token = IERC20(_token);\r\n    }\r\n\r\n    function allocateTokens(\r\n        address[] calldata _wallets,\r\n        string[] calldata names,\r\n        uint256[] calldata amounts\r\n    ) external onlyOwner {\r\n        require(\r\n            _wallets.length == names.length && names.length == amounts.length,\r\n            \"Mismatched input lengths\"\r\n        );\r\n\r\n        for (uint256 i = 0; i < _wallets.length; ++i) {\r\n            wallets.push(_wallets[i]);\r\n            membersInfo.push(Member({\r\n                name: names[i],\r\n                balance: amounts[i],\r\n                startTime: block.timestamp,\r\n                withdrawn: 0\r\n            }));\r\n            totalAllocated += amounts[i];\r\n        }\r\n    }\r\n\r\n    function withdraw() external {\r\n        uint256 index = getMemberIndex(msg.sender);\r\n        require(index != NOT_FOUND, \"No Member wallet\");\r\n\r\n        Member storage member = membersInfo[index];\r\n        uint256 withdrawable = calculateWithdrawable(member);\r\n        require(withdrawable > 0, \"Nothing to withdraw\");\r\n\r\n        member.withdrawn += withdrawable;\r\n        totalWithdrawn += withdrawable;\r\n        token.transfer(msg.sender, withdrawable);\r\n    }\r\n\r\n    function getWithdrawable() external view returns (uint256) {\r\n        uint256 index = getMemberIndex(msg.sender);\r\n        require(index != NOT_FOUND, \"No Member wallet\");\r\n        return calculateWithdrawable(membersInfo[index]);\r\n    }\r\n\r\n    function calculateWithdrawable(Member memory member) internal view returns (uint256) {\r\n        if (block.timestamp < member.startTime + CLIFF_DURATION) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 elapsed = block.timestamp - member.startTime;\r\n        uint256 vested;\r\n\r\n        if (elapsed >= VESTING_DURATION) {\r\n            vested = member.balance;\r\n        } else {\r\n            // 20% after cliff, remaining linearly over remaining time\r\n            uint256 initial = member.balance / 5;\r\n            uint256 linearPart = (member.balance * 4 * (elapsed - CLIFF_DURATION)) / (VESTING_DURATION * 5);\r\n            vested = initial + linearPart;\r\n        }\r\n\r\n        if (vested > member.balance) vested = member.balance;\r\n\r\n        return vested - member.withdrawn;\r\n    }\r\n\r\n    function getMemberIndex(address wallet) internal view returns (uint256) {\r\n        for (uint256 i = 0; i < wallets.length; ++i) {\r\n            if (wallets[i] == wallet) return i;\r\n        }\r\n        return NOT_FOUND;\r\n    }\r\n\r\n    function getMemberCount() external view returns (uint256) {\r\n        return wallets.length;\r\n    }\r\n\r\n    function getMember(address wallet) external view returns (Member memory) {\r\n        uint256 index = getMemberIndex(wallet);\r\n        require(index != NOT_FOUND, \"No Member wallet\");\r\n        return membersInfo[index];\r\n    }\r\n}"
    },
    "contracts/MetaTxGateway.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\r\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\r\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\r\n\r\n/**\r\n * @title MetaTxGateway\r\n * @notice Gateway for executing gasless meta-transactions on any EVM chain\r\n * @dev Does not handle gas credits - relies on external relayer for credit management\r\n * @dev Only supports batch execution - single meta-transactions must be wrapped in a batch\r\n * @dev Upgradeable contract using UUPS pattern\r\n */\r\ncontract MetaTxGateway is Initializable, OwnableUpgradeable, ReentrancyGuardUpgradeable, UUPSUpgradeable {\r\n    using ECDSA for bytes32;\r\n\r\n    // EIP-712 Domain Separator\r\n    bytes32 private constant EIP712_DOMAIN_TYPEHASH = keccak256(\r\n        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\r\n    );\r\n\r\n    // EIP-712 Meta Transaction Typehash for batch transactions\r\n    bytes32 private constant META_TRANSACTION_TYPEHASH = keccak256(\r\n        \"MetaTransaction(address from,bytes metaTxData,uint256 nonce,uint256 deadline)\"\r\n    );\r\n    \r\n    // Relayer management\r\n    mapping(address => bool) public authorizedRelayers;\r\n    \r\n    // Nonce management for replay protection\r\n    mapping(address => uint256) public nonces;\r\n\r\n    // Storage for batch transaction logs\r\n    struct BatchTransactionLog {\r\n        address user;\r\n        address relayer;\r\n        bytes metaTxData;\r\n        uint256 gasUsed;\r\n        uint256 timestamp;\r\n        bool[] successes;\r\n    }\r\n\r\n    // Mapping from batch transaction ID to log\r\n    mapping(uint256 => BatchTransactionLog) public batchTransactionLogs;\r\n    uint256 public nextBatchId;\r\n\r\n    // Separate mapping for storing decoded transactions\r\n    mapping(uint256 => MetaTransaction[]) public batchTransactions;\r\n\r\n    struct MetaTransaction {\r\n        address to;        // Target contract to call\r\n        uint256 value;     // ETH value to send (usually 0)\r\n        bytes data;        // Function call data\r\n    }\r\n\r\n    event RelayerAuthorized(address indexed relayer, bool authorized);\r\n    event MetaTransactionExecuted(\r\n        address indexed user,\r\n        address indexed relayer,\r\n        address indexed target,\r\n        bool success\r\n    );\r\n    event BatchTransactionExecuted(\r\n        uint256 indexed batchId,\r\n        address indexed user,\r\n        address indexed relayer,\r\n        uint256 gasUsed,\r\n        uint256 transactionCount\r\n    );\r\n\r\n    /// @custom:oz-upgrades-unsafe-allow constructor\r\n    constructor() {\r\n        _disableInitializers();\r\n    }\r\n\r\n    /**\r\n     * @dev Initializes the contract with the initial owner\r\n     * @notice This function can only be called once during deployment\r\n     */\r\n    function initialize() public initializer {\r\n        __Ownable_init();\r\n        __ReentrancyGuard_init();\r\n        __UUPSUpgradeable_init();\r\n    }\r\n\r\n    // Owner functions ==============================================\r\n\r\n    /**\r\n     * @notice Authorize/deauthorize a relayer\r\n     * @param relayer Relayer address\r\n     * @param authorized True to authorize, false to deauthorize\r\n     */\r\n    function setRelayerAuthorization(address relayer, bool authorized) external onlyOwner {\r\n        require(relayer != address(0), \"Invalid relayer address\");\r\n        authorizedRelayers[relayer] = authorized;\r\n        emit RelayerAuthorized(relayer, authorized);\r\n    }\r\n\r\n    // Meta-transaction functions ================================\r\n\r\n    /**\r\n     * @notice Execute a meta-transaction on behalf of a user (internal use only)\r\n     * @param from User's address\r\n     * @param metaTx Meta-transaction data\r\n     * @return success True if the transaction was successful\r\n     */\r\n    function _executeMetaTransaction(\r\n        address from,\r\n        MetaTransaction memory metaTx\r\n    ) internal returns (bool success) {\r\n        // Execute the transaction with try-catch to handle failures gracefully\r\n        try this._safeExecuteCall(metaTx.to, metaTx.value, metaTx.data) returns (bool _success) {\r\n            success = _success;\r\n        } catch {\r\n            success = false;\r\n        }\r\n        \r\n        emit MetaTransactionExecuted(from, msg.sender, metaTx.to, success);\r\n        \r\n        return success;\r\n    }\r\n\r\n    /**\r\n     * @notice Helper function to safely execute external calls\r\n     * @dev This function is external to allow try-catch usage\r\n     */\r\n    function _safeExecuteCall(address target, uint256 value, bytes calldata data) external returns (bool success) {\r\n        require(msg.sender == address(this), \"Only self-calls allowed\");\r\n        (success, ) = target.call{value: value}(data);\r\n        return success;\r\n    }\r\n\r\n    /**\r\n     * @notice Batch execute multiple meta-transactions\r\n     * @param from User's address\r\n     * @param metaTxData Encoded bytes of Array of meta-transactions\r\n     * @param signature signature corresponding to entire meta transaction\r\n     * @param nonce User's nonce\r\n     * @param deadline Transaction deadline\r\n     * @return successes Array of success status for each transaction\r\n     */\r\n    function executeMetaTransactions(\r\n        address from,\r\n        bytes calldata metaTxData,\r\n        bytes calldata signature,\r\n        uint256 nonce,\r\n        uint256 deadline\r\n    ) external nonReentrant returns (bool[] memory successes) {\r\n        uint256 batchGasStart = gasleft();\r\n        \r\n        require(authorizedRelayers[msg.sender], \"Unauthorized relayer\");\r\n        require(block.timestamp <= deadline, \"Transaction expired\");\r\n        require(nonce == nonces[from], \"Invalid nonce\");\r\n        require(_verifySignature(from, metaTxData, signature, nonce, deadline), \"Invalid signature\");\r\n\r\n        MetaTransaction[] memory metaTxs = abi.decode(metaTxData, (MetaTransaction[]));\r\n        require(metaTxs.length > 0, \"Empty batch Txs\");     \r\n\r\n        successes = new bool[](metaTxs.length);\r\n\r\n        // Store batch transaction log\r\n        uint256 batchId = nextBatchId++;\r\n\r\n        // Execute all transactions in the batch\r\n        for (uint256 i = 0; i < metaTxs.length; i++) {\r\n            bool success = _executeMetaTransaction(from, metaTxs[i]);\r\n            \r\n            batchTransactionLogs[batchId].successes.push(success);\r\n            batchTransactions[batchId].push(metaTxs[i]);\r\n        }\r\n\r\n        // Increment nonce to prevent replay\r\n        nonces[from]++;\r\n        \r\n        // Calculate total gas used for the entire batch\r\n        uint256 totalGasUsed = batchGasStart - gasleft() + 21000; // Add base transaction cost\r\n\r\n        batchTransactionLogs[batchId].user = from;\r\n        batchTransactionLogs[batchId].relayer = msg.sender;\r\n        batchTransactionLogs[batchId].metaTxData = metaTxData;\r\n        batchTransactionLogs[batchId].gasUsed = totalGasUsed;\r\n        batchTransactionLogs[batchId].timestamp = block.timestamp;\r\n\r\n        // Emit batch transaction event\r\n        emit BatchTransactionExecuted(batchId, from, msg.sender, totalGasUsed, metaTxs.length);\r\n\r\n        return successes;\r\n    }\r\n\r\n    // Helper functions ==========================================\r\n\r\n    /**\r\n     * @notice Verify EIP-712 signature for batch meta-transactions\r\n     * @param from User's address\r\n     * @param metaTxData Encoded bytes of Meta-transactions data\r\n     * @param signature User's signature\r\n     * @param nonce User's nonce\r\n     * @param deadline User's deadline\r\n     * @return valid True if signature is valid\r\n     */\r\n    function _verifySignature(\r\n        address from,\r\n        bytes calldata metaTxData,\r\n        bytes calldata signature,\r\n        uint256 nonce,\r\n        uint256 deadline\r\n    ) internal view returns (bool valid) {\r\n        bytes32 domainSeparator = this.getDomainSeparator();\r\n\r\n        bytes32 structHash = keccak256(abi.encode(\r\n            META_TRANSACTION_TYPEHASH,\r\n            from,\r\n            keccak256(metaTxData),\r\n            nonce,\r\n            deadline\r\n        ));\r\n\r\n        bytes32 digest = keccak256(abi.encodePacked(\r\n            \"\\x19\\x01\",\r\n            domainSeparator,\r\n            structHash\r\n        ));\r\n\r\n        address recoveredSigner = digest.recover(signature);\r\n        return recoveredSigner == from;\r\n    }\r\n\r\n    // View functions ============================================\r\n\r\n    /**\r\n     * @notice Get the current nonce for a user\r\n     * @param user User address\r\n     * @return currentNonce Current nonce value\r\n     */\r\n    function getNonce(address user) external view returns (uint256 currentNonce) {\r\n        return nonces[user];\r\n    }\r\n\r\n    /**\r\n     * @notice Check if a relayer is authorized\r\n     * @param relayer Relayer address\r\n     * @return isAuthorized True if relayer is authorized\r\n     */\r\n    function isRelayerAuthorized(address relayer) external view returns (bool isAuthorized) {\r\n        return authorizedRelayers[relayer];\r\n    }\r\n\r\n    /**\r\n     * @notice Get the domain separator for EIP-712\r\n     * @return separator Domain separator hash\r\n     */\r\n    function getDomainSeparator() external view returns (bytes32 separator) {\r\n        return keccak256(abi.encode(\r\n            EIP712_DOMAIN_TYPEHASH,\r\n            keccak256(\"MetaTxGateway\"),\r\n            keccak256(\"1\"),\r\n            block.chainid,\r\n            address(this)\r\n        ));\r\n    }\r\n\r\n    /**\r\n     * @notice Get batch transaction log by ID\r\n     * @param batchId Batch transaction ID\r\n     * @return log Batch transaction log\r\n     */\r\n    function getBatchTransactionLog(uint256 batchId) external view returns (BatchTransactionLog memory log) {\r\n        require(batchId < nextBatchId, \"Invalid batch ID\");\r\n        return batchTransactionLogs[batchId];\r\n    }\r\n\r\n    /**\r\n     * @notice Get batch transaction gas usage by ID\r\n     * @param batchId Batch transaction ID\r\n     * @return gasUsed Gas used for the batch transaction\r\n     */\r\n    function getBatchGasUsed(uint256 batchId) external view returns (uint256 gasUsed) {\r\n        require(batchId < nextBatchId, \"Invalid batch ID\");\r\n        return batchTransactionLogs[batchId].gasUsed;\r\n    }\r\n\r\n    /**\r\n     * @notice Get batch transaction successes by ID\r\n     * @param batchId Batch transaction ID\r\n     * @return successes Array of success status for each transaction in the batch\r\n     */\r\n    function getBatchSuccesses(uint256 batchId) external view returns (bool[] memory successes) {\r\n        require(batchId < nextBatchId, \"Invalid batch ID\");\r\n        return batchTransactionLogs[batchId].successes;\r\n    }\r\n\r\n    /**\r\n     * @notice Get total number of batch transactions processed\r\n     * @return count Total batch transaction count\r\n     */\r\n    function getTotalBatchCount() external view returns (uint256 count) {\r\n        return nextBatchId;\r\n    }\r\n\r\n    /**\r\n     * @notice Get decoded transactions from a batch by ID\r\n     * @param batchId Batch transaction ID\r\n     * @return transactions Array of MetaTransaction structs in the batch\r\n     */\r\n    function getBatchTransactions(uint256 batchId) external view returns (MetaTransaction[] memory transactions) {\r\n        require(batchId < nextBatchId, \"Invalid batch ID\");\r\n        return batchTransactions[batchId];\r\n    }\r\n\r\n    // Upgrade authorization =====================================\r\n\r\n    /**\r\n     * @dev Authorizes contract upgrades (UUPS pattern)\r\n     * @param newImplementation The address of the new implementation\r\n     * @notice Only owner can authorize upgrades\r\n     */\r\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\r\n}"
    },
    "contracts/mock/MockAggregatorV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport {AggregatorV3Interface} from \"@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol\";\r\n\r\ncontract MockAggregatorV3 is AggregatorV3Interface {\r\n    int256 private _price;\r\n    uint8 private _decimals;\r\n\r\n    constructor(int256 initialPrice, uint8 decimals_) {\r\n        _price = initialPrice;\r\n        _decimals = decimals_;\r\n    }\r\n\r\n    function decimals() external view override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function description() external pure override returns (string memory) {\r\n        return \"MockAggregator\";\r\n    }\r\n\r\n    function version() external pure override returns (uint256) {\r\n        return 1;\r\n    }\r\n\r\n    function getRoundData(uint80)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            uint80 roundId,\r\n            int256 answer,\r\n            uint256 startedAt,\r\n            uint256 updatedAt,\r\n            uint80 answeredInRound\r\n        )\r\n    {\r\n        return (0, _price, 0, 0, 0);\r\n    }\r\n\r\n    function latestRoundData()\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            uint80,\r\n            int256 answer,\r\n            uint256,\r\n            uint256,\r\n            uint80\r\n        )\r\n    {\r\n        return (0, _price, 0, 0, 0);\r\n    }\r\n\r\n    function updatePrice(int256 newPrice) external {\r\n        _price = newPrice;\r\n    }\r\n}"
    },
    "contracts/mock/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\n\r\ncontract MockERC20 is ERC20 {\r\n    uint8 private _decimals;\r\n\r\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) ERC20(name_, symbol_) {\r\n        _decimals = decimals_;\r\n    }\r\n\r\n    function mint(address to, uint256 amount) external {\r\n        _mint(to, amount);\r\n    }\r\n\r\n    function decimals() public view override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}"
    },
    "contracts/mock/MockUSDC.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport './MockERC20.sol';\r\n\r\ncontract MockUSDC is MockERC20 {\r\n\r\n    constructor() MockERC20(\"USD Coin\", \"USDC\", 18) {\r\n        _mint(0xa9315C1C008c022c4145E993eC9d1a3AF73D0A62, 1000_000 ether);\r\n    }\r\n}"
    },
    "contracts/mock/MockUSDT.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport './MockERC20.sol';\r\n\r\ncontract MockUSDT is MockERC20 {\r\n\r\n    constructor() MockERC20(\"Teather USD\", \"USDT\", 18) {\r\n        _mint(0xa9315C1C008c022c4145E993eC9d1a3AF73D0A62, 1000_000 ether);\r\n    }\r\n}"
    },
    "contracts/TeamAllocation.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ncontract TeamAllocation is Ownable {\r\n    struct Member {\r\n        string name;\r\n        uint256 balance;\r\n        uint256 startTime;\r\n        uint256 withdrawn;\r\n    }\r\n\r\n    IERC20 public immutable token;\r\n\r\n    uint256 public constant VESTING_DURATION = 180 days;\r\n    uint256 public constant CLIFF_DURATION = 30 days;\r\n    uint256 private constant NOT_FOUND = type(uint256).max;\r\n\r\n    address[] public wallets;\r\n    Member[] public membersInfo;\r\n\r\n    uint256 public totalAllocated;\r\n    uint256 public totalWithdrawn;\r\n\r\n    constructor(address _token, address _owner) Ownable(_owner) {\r\n        token = IERC20(_token);\r\n    }\r\n\r\n    function allocateTokens(\r\n        address[] calldata _wallets,\r\n        string[] calldata names,\r\n        uint256[] calldata amounts\r\n    ) external onlyOwner {\r\n        require(\r\n            _wallets.length == names.length && names.length == amounts.length,\r\n            \"Mismatched input lengths\"\r\n        );\r\n\r\n        for (uint256 i = 0; i < _wallets.length; ++i) {\r\n            wallets.push(_wallets[i]);\r\n            membersInfo.push(Member({\r\n                name: names[i],\r\n                balance: amounts[i],\r\n                startTime: block.timestamp,\r\n                withdrawn: 0\r\n            }));\r\n            totalAllocated += amounts[i];\r\n        }\r\n    }\r\n\r\n    function withdraw() external {\r\n        uint256 index = getMemberIndex(msg.sender);\r\n        require(index != NOT_FOUND, \"No Member wallet\");\r\n\r\n        Member storage member = membersInfo[index];\r\n        uint256 withdrawable = calculateWithdrawable(member);\r\n        require(withdrawable > 0, \"Nothing to withdraw\");\r\n\r\n        member.withdrawn += withdrawable;\r\n        totalWithdrawn += withdrawable;\r\n        token.transfer(msg.sender, withdrawable);\r\n    }\r\n\r\n    function getWithdrawable() external view returns (uint256) {\r\n        uint256 index = getMemberIndex(msg.sender);\r\n        require(index != NOT_FOUND, \"No Member wallet\");\r\n        return calculateWithdrawable(membersInfo[index]);\r\n    }\r\n\r\n    function calculateWithdrawable(Member memory member) internal view returns (uint256) {\r\n        if (block.timestamp < member.startTime + CLIFF_DURATION) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 elapsed = block.timestamp - member.startTime;\r\n        uint256 vested;\r\n\r\n        if (elapsed >= VESTING_DURATION) {\r\n            vested = member.balance;\r\n        } else {\r\n            // 20% after cliff, remaining linearly over remaining time\r\n            uint256 initial = member.balance / 5;\r\n            uint256 linearPart = (member.balance * 4 * (elapsed - CLIFF_DURATION)) / (VESTING_DURATION * 5);\r\n            vested = initial + linearPart;\r\n        }\r\n\r\n        if (vested > member.balance) vested = member.balance;\r\n\r\n        return vested - member.withdrawn;\r\n    }\r\n\r\n    function getMemberIndex(address wallet) internal view returns (uint256) {\r\n        for (uint256 i = 0; i < wallets.length; ++i) {\r\n            if (wallets[i] == wallet) return i;\r\n        }\r\n        return NOT_FOUND;\r\n    }\r\n\r\n    function getMemberCount() external view returns (uint256) {\r\n        return wallets.length;\r\n    }\r\n\r\n    function getMember(address wallet) external view returns (Member memory) {\r\n        uint256 index = getMemberIndex(wallet);\r\n        require(index != NOT_FOUND, \"No Member wallet\");\r\n        return membersInfo[index];\r\n    }\r\n}"
    },
    "contracts/TokenAirdrop.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ncontract TokenAirdrop is Ownable {\r\n    IERC20 public immutable token;\r\n    bytes32 public merkleRoot;    \r\n    uint256 public startTimestamp;\r\n    uint256 public endTimestamp;\r\n    mapping(address => bool) public hasClaimed;\r\n\r\n    event Claimed(address indexed account, uint256 amount);\r\n    event MerkleRootUpdated(bytes32 indexed newRoot);\r\n    event AirdropWindowUpdated(uint256, uint256);\r\n\r\n    constructor(address _token, address _owner) Ownable(_owner) {\r\n        require(_token != address(0), \"Invalid token address\");\r\n        token = IERC20(_token);\r\n    }\r\n\r\n    modifier airdropActive() {\r\n        require(block.timestamp >= startTimestamp, \"Sale not started\");\r\n        require(block.timestamp <= endTimestamp, \"Sale ended\");\r\n        _;\r\n    }\r\n\r\n    function setAirdropWindow(uint256 _start, uint256 _end) external onlyOwner {\r\n        require(_start < _end, \"Invalid time range\");\r\n        startTimestamp = _start;\r\n        endTimestamp = _end;\r\n        emit AirdropWindowUpdated(_start, _end);\r\n    }\r\n\r\n    function updateMerkleRoot(bytes32 newRoot) external onlyOwner {\r\n        merkleRoot = newRoot;\r\n        emit MerkleRootUpdated(newRoot);\r\n    }\r\n\r\n    function claim(uint256 amount, bytes32[] calldata proof) external airdropActive {\r\n        require(!hasClaimed[msg.sender], \"Already claimed\");\r\n        require(merkleRoot != bytes32(0), \"Merkle root not set\");\r\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender, amount));\r\n        require(MerkleProof.verify(proof, merkleRoot, leaf), \"Invalid proof\");\r\n\r\n        hasClaimed[msg.sender] = true;\r\n        require(token.transfer(msg.sender, amount), \"Transfer failed\");\r\n\r\n        emit Claimed(msg.sender, amount);\r\n    }\r\n\r\n    function recoverRemaining(address to) external onlyOwner {\r\n        uint256 balance = token.balanceOf(address(this));\r\n        require(token.transfer(to, balance), \"Withdraw failed\");\r\n    }\r\n}"
    },
    "contracts/TokenPresale.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\n\r\ninterface AggregatorV3Interface {\r\n    function latestRoundData()\r\n        external\r\n        view\r\n        returns (uint80, int256 answer, uint256, uint256, uint80);\r\n}\r\n\r\ncontract TokenPresale is Ownable, ReentrancyGuard {\r\n    IERC20 public immutable saleToken;\r\n    uint256 public immutable totalTokensForSale;\r\n    uint256 public tokensSold;\r\n    uint256 constant baseRatePerUSD = 20; // 20 sale tokens per $1\r\n    uint256 public startTimestamp;\r\n    uint256 public endTimestamp;\r\n    event SaleWindowUpdated(uint256, uint256);\r\n\r\n    struct PaymentToken {\r\n        address token;\r\n        address priceFeed; // Chainlink USD price feed\r\n        uint8 decimals;\r\n        bool isStable;\r\n        bool isAllowed;\r\n    }\r\n\r\n    mapping(address => PaymentToken) public paymentTokens;\r\n\r\n    event Purchased(address indexed buyer, address indexed payToken, uint256 payAmount, uint256 tokenAmount);\r\n\r\n    constructor(address _saleToken, uint256 _totalForSale, address _owner) Ownable(_owner) {\r\n        saleToken = IERC20(_saleToken);\r\n        totalTokensForSale = _totalForSale;\r\n    }\r\n\r\n    modifier saleActive() {\r\n        require(block.timestamp >= startTimestamp, \"Sale not started\");\r\n        require(block.timestamp <= endTimestamp, \"Sale ended\");\r\n        _;\r\n    }\r\n\r\n    modifier saleOngoing() {\r\n        require(endTimestamp == 0 || block.timestamp < endTimestamp, \"Sale ended\");\r\n        _;\r\n    }\r\n\r\n    function setSaleWindow(uint256 _start, uint256 _end) external onlyOwner saleOngoing {\r\n        require(_start < _end, \"Invalid time range\");\r\n        startTimestamp = _start;\r\n        endTimestamp = _end;\r\n        emit SaleWindowUpdated(_start, _end);\r\n    }\r\n\r\n    function addPaymentToken(\r\n        address token,\r\n        address priceFeed,\r\n        uint8 decimals,\r\n        bool isStable\r\n    ) external onlyOwner {\r\n        paymentTokens[token] = PaymentToken({\r\n            token: token,\r\n            priceFeed: priceFeed,\r\n            decimals: decimals,\r\n            isStable: isStable,\r\n            isAllowed: true\r\n        });\r\n    }\r\n\r\n    function getTokenPriceInUSD(address token) public view returns (uint256) {\r\n        require(paymentTokens[token].isAllowed, \"Token not allowed\");\r\n        if (paymentTokens[token].isStable) {\r\n            return 1e8;\r\n        }\r\n        \r\n        (, int256 price,,,) = AggregatorV3Interface(paymentTokens[token].priceFeed).latestRoundData();\r\n        require(price > 0, \"Invalid price\");\r\n        \r\n        return uint256(price); // 8 decimals typically\r\n    }\r\n\r\n    // Power curve rate: rate = 1 + 1.25 * (1 - x^2)\r\n    function getDynamicRate() public view returns (uint256) {\r\n        uint256 remaining = totalTokensForSale - tokensSold;\r\n        uint256 remainingInBps =  remaining * 1e18 / totalTokensForSale;\r\n\r\n        uint256 squared = (remainingInBps * remainingInBps) / 1e18;\r\n        uint256 factor = 1e18 + 2e18 * (1e18 - squared) / 1e18;\r\n\r\n        return factor / baseRatePerUSD;\r\n    }\r\n\r\n    function convertDecimals(uint256 amount, uint8 from, uint8 to) internal pure returns (uint256) {\r\n        unchecked {\r\n            return from > to ? \r\n                amount / (10 ** (from - to)) :\r\n                amount * (10 ** (to - from));\r\n        }\r\n    }\r\n\r\n    function calculateTokenAmount(address payToken, uint256 amountIn) public view returns (uint256 tokenAmount) {\r\n        require(paymentTokens[payToken].isAllowed, \"Token not allowed\");\r\n        PaymentToken memory info = paymentTokens[payToken];\r\n        uint256 tokenUSDPrice = getTokenPriceInUSD(payToken);\r\n        uint256 dynamicRate = getDynamicRate();\r\n\r\n        tokenAmount = (convertDecimals(amountIn, info.decimals, 18) * tokenUSDPrice * 1e18) / (dynamicRate * 1e8); // Normalize decimals\r\n        require(tokensSold + tokenAmount <= totalTokensForSale, \"Exceeds sale supply\");\r\n    }\r\n\r\n    function buyTokens(address payToken, uint256 amountIn) external nonReentrant saleActive {\r\n        require(paymentTokens[payToken].isAllowed, \"Unsupported payment token\");\r\n        require(amountIn > 0, \"Invalid amount\");\r\n\r\n        uint256 tokenAmount = calculateTokenAmount(payToken, amountIn);\r\n\r\n        // Transfer stable token to contract\r\n        IERC20(payToken).transferFrom(msg.sender, address(this), amountIn);\r\n\r\n        // Transfer sale tokens to buyer\r\n        saleToken.transfer(msg.sender, tokenAmount);\r\n        tokensSold += tokenAmount;\r\n\r\n        emit Purchased(msg.sender, payToken, amountIn, tokenAmount);\r\n    }\r\n\r\n    function buyTokens() public payable nonReentrant saleActive {\r\n        require(msg.value > 0, \"Invalid amount\");\r\n\r\n        uint256 tokenAmount = calculateTokenAmount(address(0), msg.value);\r\n\r\n        // Transfer sale tokens to buyer\r\n        saleToken.transfer(msg.sender, tokenAmount);\r\n        tokensSold += tokenAmount;\r\n\r\n        emit Purchased(msg.sender, address(0), msg.value, tokenAmount);\r\n    }\r\n\r\n    function withdraw(address token, address to) external onlyOwner {\r\n        uint256 bal = IERC20(token).balanceOf(address(this));\r\n        require(bal > 0, \"Nothing to withdraw\");\r\n        IERC20(token).transfer(to, bal);\r\n    }\r\n\r\n    function remainingTokens() external view returns (uint256) {\r\n        return totalTokensForSale - tokensSold;\r\n    }\r\n\r\n    receive() external payable {\r\n        buyTokens();\r\n    } \r\n}"
    },
    "contracts/TokenStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\ncontract TokenStaking is Ownable {\r\n    IERC20 public immutable stakingToken;\r\n\r\n    struct StakeInfo {\r\n        uint256 amount;\r\n        uint256 startTime;\r\n        uint256 endTime;\r\n        LockDuration lockDuration;\r\n        uint256 stakingShare;\r\n        uint256 rewardDebt;\r\n        uint256 claimedReward;\r\n        uint256 pendingReward;\r\n        uint256 totalAccumulatedReward;\r\n        bool withdrawn;\r\n    }\r\n\r\n    struct TotalStakeInfo {\r\n        uint256 totalStaked;\r\n        uint256 stakingShare;\r\n        uint256 rewardIndex;\r\n        uint256 lastUpdatedAt;\r\n        uint256 totalRewardDistributed;\r\n        uint256 lastDistributedAt;\r\n    }\r\n\r\n    enum LockDuration {\r\n        NORMAL,\r\n        QUATERLY,\r\n        HALF_YEARLY,\r\n        YEARLY\r\n    }\r\n\r\n    uint256 constant YEAR = 365 days;\r\n    uint256 constant DISTRIBITE_UNIT = 10_000 ether;\r\n    uint256 constant totalRewardTokens = 100_000_000 ether;\r\n    \r\n    mapping(address => StakeInfo[]) public userStakes;\r\n    TotalStakeInfo public totalStakes;\r\n\r\n    uint256 public rewardMultiplier = 1e18;\r\n    uint256 public stakingStartedAt;\r\n    bool public stakingEnded;\r\n\r\n    event RewardMultiplierUpdated(uint256);\r\n    event Staked(address indexed user, uint256 stakedAmount, LockDuration duration);\r\n    event Withdrawn(address indexed user, uint256 stakeIndex, uint256 amount);\r\n    event ClaimedReward(address indexed user, uint256 stakeIndex, uint256 reward);\r\n\r\n    constructor(address _stakingToken, address _owner) Ownable(_owner) {\r\n        stakingToken = IERC20(_stakingToken);\r\n    }\r\n    \r\n    function updateDistributeRate(uint256 newMultiplier) external onlyOwner accrueReward {\r\n        rewardMultiplier = newMultiplier;\r\n        emit RewardMultiplierUpdated(newMultiplier);\r\n    }\r\n\r\n    function setStartTimeForStaking(uint256 startAt) external onlyOwner {\r\n        require(stakingStartedAt == 0, 'Staking already started');\r\n        require(startAt > block.timestamp, 'Invalid timestamp');\r\n\r\n        stakingStartedAt = startAt;\r\n    }\r\n\r\n    modifier stakingActive() {\r\n        require(stakingStartedAt != 0 && block.timestamp >= stakingStartedAt, 'Staking not started');\r\n        require(!stakingEnded, 'Staking ended');\r\n        _;\r\n    }\r\n\r\n    function stake(uint256 amount, LockDuration duration) external stakingActive {\r\n        require(amount > 0, \"Amount must be > 0\");\r\n\r\n        stakingToken.transferFrom(msg.sender, address(this), amount);\r\n\r\n        userStakes[msg.sender].push(StakeInfo({\r\n            amount: amount,\r\n            startTime: block.timestamp,\r\n            endTime: block.timestamp + getLockDuration(duration),\r\n            lockDuration: duration,\r\n            stakingShare: 0,\r\n            rewardDebt: 0,\r\n            claimedReward: 0,\r\n            pendingReward: 0,\r\n            totalAccumulatedReward: 0,\r\n            withdrawn: false\r\n        }));\r\n\r\n        updateStakingShare(msg.sender);\r\n        emit Staked(msg.sender, amount, duration);\r\n    }\r\n\r\n    function withdraw(uint256 stakeIndex) external {\r\n        StakeInfo storage info = userStakes[msg.sender][stakeIndex];\r\n        require(!info.withdrawn, \"Already withdrawn\");\r\n        require(block.timestamp >= info.startTime + getLockDuration(info.lockDuration) || stakingEnded, \"Lock not expired\");\r\n\r\n        claimReward(stakeIndex);\r\n        // Update total stakes (subtract the withdrawn amount and share)\r\n        info.withdrawn = true;\r\n        totalStakes.totalStaked -= info.amount;\r\n        totalStakes.stakingShare -= info.stakingShare;\r\n\r\n        stakingToken.transfer(msg.sender, info.amount);\r\n\r\n        emit Withdrawn(msg.sender, stakeIndex, info.amount);\r\n    }\r\n\r\n    function claimReward(uint256 stakeIndex) public accrueReward {\r\n        require(stakeIndex < userStakes[msg.sender].length, \"Invalid stake index\");\r\n        StakeInfo storage info = userStakes[msg.sender][stakeIndex];\r\n        require(!info.withdrawn, \"Stake already withdrawn\");\r\n\r\n        uint256 pending = calculateClaimableReward(info);\r\n        require(pending > 0, \"No reward available\");\r\n\r\n        // Update all reward tracking fields\r\n        info.claimedReward += pending;\r\n        info.rewardDebt = (info.stakingShare * totalStakes.rewardIndex) / 1e18;\r\n\r\n        stakingToken.transfer(msg.sender, pending);\r\n        emit ClaimedReward(msg.sender, stakeIndex, pending);\r\n    }\r\n\r\n    function calculateClaimableReward(StakeInfo memory info) public view returns (uint256) {\r\n        if (info.withdrawn) \r\n            return 0;\r\n\r\n        uint256 accumulated = (info.stakingShare * totalStakes.rewardIndex) / 1e18;\r\n        if (accumulated < info.rewardDebt) return 0;\r\n        return accumulated - info.rewardDebt;\r\n    }\r\n\r\n    function updateStakingShare(address user) internal accrueReward {\r\n        StakeInfo storage userStake = userStakes[user][userStakes[user].length - 1];\r\n        uint256 share = calculateStakingShare(userStake.amount, userStake.lockDuration);\r\n\r\n        // Set reward debt before increasing total share\r\n        userStake.rewardDebt = (share * totalStakes.rewardIndex) / 1e18;\r\n\r\n        totalStakes.totalStaked += userStake.amount;\r\n        totalStakes.stakingShare += share;\r\n        userStake.stakingShare = share;\r\n    }\r\n\r\n    modifier accrueReward() {\r\n        if (totalStakes.lastUpdatedAt == 0)\r\n            totalStakes.lastUpdatedAt = block.timestamp;\r\n\r\n        if (block.timestamp > totalStakes.lastUpdatedAt && totalStakes.stakingShare > 0) {\r\n            uint256 duration = block.timestamp - totalStakes.lastUpdatedAt;\r\n            uint256 reward = (duration * getDistributionRate()) / 1 days;\r\n            if (reward + totalStakes.totalRewardDistributed > totalRewardTokens) {\r\n                reward = totalRewardTokens - totalStakes.totalRewardDistributed;\r\n                stakingEnded = true;\r\n            }\r\n            totalStakes.rewardIndex += (reward * 1e18) / totalStakes.stakingShare;\r\n            totalStakes.lastUpdatedAt = block.timestamp;\r\n            totalStakes.totalRewardDistributed += reward;\r\n        }\r\n        _;\r\n    }\r\n\r\n    function updateReward() external accrueReward {\r\n\r\n    }\r\n\r\n    // this is reward amount per day\r\n    function getDistributionRate() internal view returns(uint256) {\r\n        return rewardMultiplier * DISTRIBITE_UNIT/ 1e18;\r\n    }\r\n\r\n\r\n    function calculateStakingShare(uint256 amount, LockDuration duration) internal pure returns(uint256) {\r\n        return amount * getLockMultiplier(duration) * getAmountMultiplier(amount) / 1e4;\r\n    }\r\n\r\n    function calculateAPR() public view returns(uint256) {\r\n        if (totalStakes.stakingShare == 0)\r\n            return 0;\r\n\r\n        return getDistributionRate() * 365 * 1e18 / totalStakes.stakingShare;\r\n    } \r\n\r\n    function getLockDuration(LockDuration duration) public pure returns (uint256) {\r\n        if (duration == LockDuration.QUATERLY) return YEAR / 4;\r\n        if (duration == LockDuration.HALF_YEARLY) return YEAR / 2;\r\n        if (duration == LockDuration.YEARLY) return YEAR;\r\n        return 0;\r\n    }\r\n\r\n    function getLockMultiplier(LockDuration duration) public pure returns (uint256) {\r\n        if (duration == LockDuration.QUATERLY) return 125;\r\n        if (duration == LockDuration.HALF_YEARLY) return 150;\r\n        if (duration == LockDuration.YEARLY) return 200;\r\n        return 100;\r\n    }\r\n\r\n    function getAmountMultiplier(uint256 amount) public pure returns (uint256) {\r\n        if (amount >= 500_000 ether) return 250;\r\n        if (amount >= 200_000 ether) return 200;\r\n        if (amount >= 100_000 ether) return 150;\r\n        if (amount >= 50_000 ether) return 125;\r\n        if (amount >= 20_000 ether) return 115;\r\n        return 100;\r\n    }\r\n\r\n    function getStakes(address user) external view returns (StakeInfo[] memory stakes) {\r\n        stakes = userStakes[user];\r\n        for (uint256 i = 0; i < stakes.length; ++i) {\r\n            stakes[i].pendingReward = calculateClaimableReward(stakes[i]);\r\n        }\r\n    }\r\n\r\n    function getTotalStakes() external view returns (TotalStakeInfo memory) {\r\n        return totalStakes;\r\n    }\r\n} \r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ]
      }
    },
    "remappings": [
      "@openzeppelin/=node_modules/@openzeppelin/",
      "@chainlink/=node_modules/@chainlink/"
    ]
  }
}